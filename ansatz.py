from typing import Tuple, List
import numpy as np
import networkx as nx
import cirq

def gamma_layer(gamma: float, qubit_graph: nx.Graph) -> cirq.Circuit:
    gamma_ckt = cirq.Circuit()
    for q1, q2 in qubit_graph.edges:
        gamma_ckt.append(cirq.ZZ(q1, q2) ** gamma)
    return gamma_ckt


def beta_layer(beta: float, qubit_graph: nx.Graph) -> cirq.Circuit:
    beta_ckt = cirq.Circuit()
    for q in qubit_graph.nodes:
        beta_ckt.append(cirq.X(q) ** beta)
    return beta_ckt


def alpha_layer(alpha: float, qubit_graph: nx.Graph, reference: List[bool]) -> cirq.Circuit:
    alpha_ckt = cirq.Circuit()
    for i, q in enumerate(qubit_graph.nodes):
        if reference[i]:
            alpha_ckt.append(cirq.Z(q) ** alpha)
    return alpha_ckt


class CylicQAOAAnsatz:
    """Class to generate cyclic QAOA Ansatz circuits."""

    def __init__(self, qubit_graph, observable, **kwargs):
        """Initialize an instance of the CylicQAOA Ansatz.
        
        Arugments:
        qubit_graph: graph determining which qubits can interact.
        observable: observable for the problem (e.g. Hamiltonian for MaxCut)
        
        Optional keyword arguments:
        reference: list of booleans, reference bitstring for the Ansatz.
        alpha: np.ndarray, coefficient for the refence term in this Hamiltonian."""

        self.qubit_graph = qubit_graph
        self.observable = observable

        # Set up the cyclic part.
        if "reference" in kwargs.keys():
            self.use_reference = True
            self.reference = kwargs["reference"]
            if "alpha" in kwargs.keys():
                self.alpha = kwargs["alpha"]
            else:
                raise ValueError("alpha values must be provided with the reference.")
        else:
            self.use_reference = False
            if "alpha" in kwargs.keys():
                raise ValueError("Reference term must be provided alongside alpha.")
    
    @property
    def qubits(self):
        return self.qubit_graph.nodes
    
    def circuit(self, gammas: np.ndarray, betas: np.ndarray) -> cirq.Circuit:
        """Make a circuit with the given QAOA parameters. The graph determines
        the connectivity of the Ansatz."""

        assert gammas.size == betas.size

        qaoa_ckt = cirq.Circuit()
        for q in self.qubit_graph.nodes:
            qaoa_ckt.append(cirq.H(q))
        for i, (gamma, beta) in enumerate(zip(gammas, betas)):
            qaoa_ckt += gamma_layer(gamma, self.qubit_graph)
            qaoa_ckt += beta_layer(beta, self.qubit_graph)
            if self.use_reference:
                assert gammas.size == self.alpha.size, "Size of alpha and gamma must match."
                qaoa_ckt += alpha_layer(self.alpha[i], self.qubit_graph, self.reference)
        return qaoa_ckt
    
    def energy(self, gammas: np.ndarray, betas: np.ndarray) -> float:
        """Get the energy for this Ansatz with specific values."""

        qaoa_ckt = self.circuit(gammas, betas)
        sim = cirq.Simulator()
        try:
            energy = sim.simulate_expectation_values(qaoa_ckt, [self.observable])[0].real
            return energy
        except ValueError as exc:
            print(qaoa_ckt)
            qasm_str = cirq.qasm(qaoa_ckt)
            with open("circuit.qasm", "w", encoding="utf8") as f:
                f.write(qasm_str)
            raise exc

    def energy_grad(self, gammas: np.ndarray, betas: np.ndarray, eps: float=1e-5) -> Tuple[np.ndarray, np.ndarray]:
        """Get the gradient for the given values of gamma and beta. This uses a finite difference."""

        gamma_grad = np.zeros(gammas.size)
        for i in range(gammas.size):
            gamma_plus = gammas.copy()
            gamma_plus[i] += eps
            gamma_minus = gammas.copy()
            gamma_minus[i] -= eps
            plus_energy = self.energy(gamma_plus, betas)
            minus_energy = self.energy(gamma_minus, betas)
            gamma_grad[i] = (plus_energy - minus_energy) / (2.0 * eps)
        beta_grad = np.zeros(betas.size)
        for i in range(betas.size):
            beta_plus = betas.copy()
            beta_plus[i] += eps
            beta_minus = betas.copy()
            beta_minus[i] -= eps
            plus_energy = self.energy(gammas, beta_plus)
            minus_energy = self.energy(gammas, beta_minus)
            beta_grad[i] = (plus_energy - minus_energy) / (2.0 * eps)
        return gamma_grad, beta_grad
    
    def sample_bitstrings(self, gammas: np.ndarray, betas: np.ndarray, samples: int) -> np.ndarray:
        """Sample bitstrings from the final state generated by the Ansatz."""

        assert gammas.size == betas.size

        ckt = self.circuit(gammas, betas)
        # Append measurements to the end of the circuit.
        for q in ckt.all_qubits():
            ckt.append(cirq.M(q))
        sim = cirq.Simulator()
        df = sim.sample(ckt, repetitions=samples)
        return df.to_numpy()
